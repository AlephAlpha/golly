#!perl
#
#   Convert a description of a Turing machine, such as the five-state
#   busy beaver
#
#   B1L C1R C1L B1L D1L E0R A1R D1R H1L A0R
#
#   into a RuleTree file for Golly.
#
#   The above rules are interpreted in pairs; each pair is for a
#   given Turing machine state, starting with A and proceeding
#   upwards.  The first value in each pair is for a tape symbol
#   of 0, and the second value is for a tape symbol of 1.
#
#   Each entry is three characters that give, respectively, the
#   next state, the symbol to write, and whether to move the head
#   left or right.
#
#   So the above description is just a table of the form:
#
#   initial  input   next  output   head
#    state  symbol  state  symbol movement
#   ------- ------  -----  ------ --------
#      A      0       B      1       L
#      A      1       C      1       R
#      B      0       C      1       L
#      B      1       B      1       L
#      C      0       D      1       L
#      C      1       E      0       R
#      D      0       A      1       R
#      D      1       D      1       R
#      E      0       H      1       L
#      E      1       A      0       R
#
#   Any output state greater than the number of input states
#   is treated as a halt state.
#
#   The cellular automata we create from this has the tape
#   extending infinitely horizontally in both directions, with
#   state 0 being a tape symbol of 0 and state 1 being a tape
#   symbol of 1.  States 2 on up represent Turing machine states
#   A on up.  The halt state is represented by an addition state.
#   Thus, to represent an n-state Turing machine, we use a
#   cellular automaton with n+3 states.  (By reusing state 1,
#   we could reduce this to n+2.)
#
#   We take input from either the command line, or if none was
#   supplied, from standard in.  This script only supports states
#   A-Y (up to 25 states), although in principle we can easily
#   support up to 253 Turing machine states, just using a different
#   input notation.
#
#   On the input, we ignore any lines that begin with #, and we
#   also ignore any whitespace.  Everything else is accepted as
#   machine description; there must be a multiple of six characters.
#
#   We first write out a generic rule which erases the old tape
#   head on each step, if it's not a halt state.
#
#   For each triple of characters, we write out one or two rules.
#   One rule is for the new machine head.  The other rule updates
#   the tape, but only if the symbol to be written is different than
#   the input symbol.
#
#   To run one of the busy beaver Turing machines below, you should
#   start with an empty universe except for a single cell in state 2.
#
# Here are some sample inputs, along with names; these are collected from
# 
#    http://www.drb.insel.de/~heiner/BB/bb-list
# 
# 5-1 is the canonical standard 5-state busy-beaver; Golly handles this
# one pretty easily.
# 
# 5-1: B1L C1R C1L B1L D1L E0R A1R D1R H1L A0R
# 5-2: B1L A1L C1R B1R A1L D1R A1L E1R H1R C0R
# 6-1: B1L A1L C1R B1R F0R D1R A1L E0R A0L C1R E1L H1L
# 6-2: B1R A1R C1L B1L F0R D1L A1R E0L H1L F1L A0L C0L
# 6-3: B1R C0R A0L D0R D1R H1R E1L D0L F1R B1L A1R E1R
# 
# These are collected from:
# 
#    http://www.drb.insel.de/~heiner/BB/bb-6list
# 
# r is the best current 6-state busy-beaver; Golly falls all over itself
# trying to compute this one.
# 
# a: B1R C0L A1L A0R D0L Z1R E1R D1L F0L E0L F1R B0L
# b: B1R C0L A1L E0R D1L F0L B0L C1L B1R A1R B1R Z1R
# c: B1R C0L A1L E0R D1L F1L B0L C1L B1R A1R C0L Z1R
# d: B1R B0L A1L C1L B1L D0R Z1R E1R F1R A0R C0R C1L
# e: B1R C1L A0L D0L A1L Z1R B1L E1R D0R F0R D0R D0L
# g: B1R C1L A0L D0L A1L Z1R B1L E1R D0R F0R F0R D0L
# i: B1R C0L A1L D1R D1R C1L E1R F1L A0R B1R Z1R D0L
# j: B1R C0L A1L D1R B0L E0L A1R B0R F1L C1L A0L Z1R
# k: B1R C0R A0L D0R D1R Z1R E1L D0L F1R B1L A1R E1R
# l: B1R C0L A1L D1R B0L E0L A1R B0R F1L C1L D1R Z1R
# m: B1R C0L A1L D1R A1R E0L A1R B0R F1L C1L D1R Z1R
# n: B1R C0L A1L D1L D1R C0R B0L E0R C1R F1L E1L Z1R
# o: B1R C0L A1L C1R A1R D0L E1L C1L F1R Z1R A1R E1R
# p: B1R B0L C1L E0R E1R D0L A1L A1L A0R F0R E1R Z1R
# q: B1R B0L C0R B1L D1R A0L E1L F1L A1L D0L Z1R E1L
# r: B1R F0L C0R D0R D1L E1R E0L D0L A0R C1R A1L Z1R
#
my $input = "" ;
my $originput = "" ;
if (@ARGV) {
   $originput = "@ARGV" ;
} else {
   while (<>) {
       chomp ;
       next if /^#/ ;
       $originput .= $_ . " " ;
   }
}
$input = $originput ;
$input =~ s/\s//g ;
die "total input must be divisible by 6" if length($input) % 6 != 0 ;
die "bad syntax on input" if $input !~ /^([A-Z][01][LR])*$/ ;
#
my $tmstates = length($input) / 6 ;
my $treestates = 3 + $tmstates ;
my $allstates = join ',',0..$treestates-1 ;
my $nonhaltstates = join ',',2..$treestates-2 ;
print <<EOF ;
# Rules file for Turing Machine; generated by TuringConvert.pl
# Input:
#   $originput
n_states: $treestates
neighborhood:Moore
symmetries:none
var a={$allstates}
var b={$nonhaltstates}
var c={0,1}
var d={0,1}
var e={0,1}
b,0,0,0,c,d,e,0,0,0
EOF
for (my $i=0; $i<$tmstates*2; $i++) {
    my $istate = $i >> 1 ;
    my $ival = $i & 1 ;
    my $ostate = ord(substr($input, $i*3, 1)) - ord('A') ;
    my $oval = substr($input, $i*3+1, 1) ;
    my $lr = substr($input, $i*3+2, 1) ;
    $ostate = $tmstates if $ostate > $tmstates ;
    $ostate += 2 ;
    $istate += 2 ;
#   Create the new head in the new state.
    if ($lr eq 'L') {
        print "0,0,0,$istate,$ival,c,d,0,0,$ostate\n" ;
    } else {
        print "0,0,0,0,c,d,$ival,$istate,0,$ostate\n" ;
    }
#   Write the new value if different from the old.
    if ($oval != $ival) {
        print "$ival,$istate,0,c,0,0,0,d,0,$oval\n" ;
    }
}
