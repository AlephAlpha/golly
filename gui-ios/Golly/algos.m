/*** /
 
 This file is part of Golly, a Game of Life Simulator.
 Copyright (C) 2012 Andrew Trevorrow and Tomas Rokicki.
 
 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 2
 of the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 
 Web site:  http://sourceforge.net/projects/golly
 Authors:   rokicki@gmail.com  andrew@trevorrow.com
 
 / ***/

#include "bigint.h"
#include "lifealgo.h"
#include "qlifealgo.h"
#include "hlifealgo.h"
#include "jvnalgo.h"
#include "generationsalgo.h"
#include "ruleloaderalgo.h"

#include "utils.h"      // for Fatal, Warning, SetColor, Poller
#include "prefs.h"      // for maxhashmem
#include "file.h"       // for GetBaseName
#include "layer.h"      // for currlayer
#include "algos.h"

// -----------------------------------------------------------------------------

// exported data:

algo_type initalgo = QLIFE_ALGO;    // initial algorithm
AlgoData* algoinfo[MAX_ALGOS];      // static info for each algorithm

CGImageRef* hexicons7x7;            // hexagonal icon bitmaps for scale 1:8
CGImageRef* hexicons15x15;          // hexagonal icon bitmaps for scale 1:16
CGImageRef* hexicons31x31;          // hexagonal icon bitmaps for scale 1:32

CGImageRef* vnicons7x7;             // diamond-shaped icon bitmaps for scale 1:8
CGImageRef* vnicons15x15;           // diamond-shaped icon bitmaps for scale 1:16
CGImageRef* vnicons31x31;           // diamond-shaped icon bitmaps for scale 1:32

// -----------------------------------------------------------------------------

// These default cell colors were generated by continuously finding the
// color furthest in rgb space from the closest of the already selected
// colors, black, and white.
static unsigned char default_colors[] = {
48,48,48, // better if state 0 is dark gray (was 255,127,0)
0,255,127,127,0,255,148,148,148,128,255,0,255,0,128,
0,128,255,1,159,0,159,0,1,255,254,96,0,1,159,96,255,254,
254,96,255,126,125,21,21,126,125,125,21,126,255,116,116,116,255,116,
116,116,255,228,227,0,28,255,27,255,27,28,0,228,227,227,0,228,
27,28,255,59,59,59,234,195,176,175,196,255,171,194,68,194,68,171,
68,171,194,72,184,71,184,71,72,71,72,184,169,255,188,252,179,63,
63,252,179,179,63,252,80,9,0,0,80,9,9,0,80,255,175,250,
199,134,213,115,100,95,188,163,0,0,188,163,163,0,188,203,73,0,
0,203,73,73,0,203,94,189,0,189,0,94,0,94,189,187,243,119,
55,125,32,125,32,55,32,55,125,255,102,185,102,185,255,120,209,168,
208,166,119,135,96,192,182,255,41,83,153,130,247,88,55,89,247,55,
88,55,247,87,75,0,0,87,75,75,0,87,200,135,59,51,213,127,
255,255,162,255,37,182,37,182,255,228,57,117,142,163,210,57,117,228,
193,255,246,188,107,123,123,194,107,145,59,5,5,145,59,59,5,145,
119,39,198,40,197,23,197,23,40,23,40,197,178,199,158,255,201,121,
134,223,223,39,253,84,149,203,15,203,15,149,15,149,203,152,144,90,
143,75,139,71,97,132,224,65,219,65,219,224,255,255,40,218,223,69,
74,241,0,241,0,74,0,74,241,122,171,51,220,211,227,61,127,87,
90,124,176,36,39,13,165,142,255,255,38,255,38,255,255,83,50,107,
224,142,165,255,181,9,9,255,181,181,9,255,140,238,70,255,74,5,
74,5,255,138,84,51,31,172,101,177,115,17,221,0,0,0,221,0,
0,0,221,220,255,200,0,41,50,255,150,205,178,45,116,113,255,189,
47,0,44,40,119,171,205,107,255,177,115,172,133,73,236,109,0,168,
168,46,207,188,181,203,212,188,35,90,97,52,39,209,184,41,164,152,
227,46,70,46,70,227,211,156,255,98,146,222,136,56,95,102,54,152,
86,142,0,142,0,86,0,86,142,86,223,96,246,135,46,4,208,120,
212,233,158,177,92,214,104,147,88,149,240,147,227,93,148,72,255,133,
209,27,194,147,255,255,44,93,0,160,36,158,182,233,0,96,94,217,
218,103,88,163,154,38,118,114,139,94,0,43,113,164,174,168,188,114,
0,23,119,42,86,93,255,226,202,80,191,155,255,158,136,0,247,62,
234,146,88,0,183,229,110,212,36,0,143,161,105,191,210,133,164,0,
41,30,89,164,0,132,30,89,42,178,222,217,121,22,11,221,107,22,
69,151,255,45,158,3,158,3,45,3,45,158,86,42,29,9,122,22,
213,209,110,53,221,57,159,101,91,93,140,45,247,213,37,185,34,0,
0,185,34,34,0,185,236,0,172,210,180,78,231,107,221,162,49,43,
43,162,49,49,43,162,36,248,213,114,0,214,213,36,248,149,34,243,
185,158,167,144,122,224,34,245,149,255,31,98,31,98,255,152,200,193,
255,80,95,128,123,63,102,62,72,255,62,148,151,226,108,159,99,255,
226,255,126,98,223,136,80,95,255,225,153,15,73,41,211,212,71,41,
83,217,187,180,235,79,0,166,127,251,135,243,229,41,0,41,0,229,
82,255,216,141,174,249,249,215,255,167,31,79,31,79,167,213,102,185,
255,215,83,4,2,40,224,171,220,41,0,4,6,50,90,221,15,113,
15,113,221,33,0,115,108,23,90,182,215,36
};

// -----------------------------------------------------------------------------

// XPM data for default 7x7 icon
static const char* default7x7[] = {
// width height ncolors chars_per_pixel
"7 7 2 1",
// colors
". c #000000",    // black will be transparent
"W c #FFFFFF",    // white
// pixels
"..WWW..",
".WWWWW.",
"WWWWWWW",
"WWWWWWW",
"WWWWWWW",
".WWWWW.",
"..WWW.."
};

// XPM data for default 15x15 icon
static const char* default15x15[] = {
// width height ncolors chars_per_pixel
"15 15 2 1",
// colors
". c #000000",    // black will be transparent
"W c #FFFFFF",    // white
// pixels
"...............",
"......WWW......",
"....WWWWWWW....",
"...WWWWWWWWW...",
"..WWWWWWWWWWW..",
"..WWWWWWWWWWW..",
".WWWWWWWWWWWWW.",
".WWWWWWWWWWWWW.",
".WWWWWWWWWWWWW.",
"..WWWWWWWWWWW..",
"..WWWWWWWWWWW..",
"...WWWWWWWWW...",
"....WWWWWWW....",
"......WWW......",
"..............."
};

// XPM data for default 31x31 icon
static const char* default31x31[] = {
// width height ncolors chars_per_pixel
"31 31 2 1",
// colors
". c #000000",    // black will be transparent
"W c #FFFFFF",    // white
// pixels
"...............................",
"...............................",
"............WWWWWWW............",
"..........WWWWWWWWWWW..........",
"........WWWWWWWWWWWWWWW........",
".......WWWWWWWWWWWWWWWWW.......",
"......WWWWWWWWWWWWWWWWWWW......",
".....WWWWWWWWWWWWWWWWWWWWW.....",
"....WWWWWWWWWWWWWWWWWWWWWWW....",
"....WWWWWWWWWWWWWWWWWWWWWWW....",
"...WWWWWWWWWWWWWWWWWWWWWWWWW...",
"...WWWWWWWWWWWWWWWWWWWWWWWWW...",
"..WWWWWWWWWWWWWWWWWWWWWWWWWWW..",
"..WWWWWWWWWWWWWWWWWWWWWWWWWWW..",
"..WWWWWWWWWWWWWWWWWWWWWWWWWWW..",
"..WWWWWWWWWWWWWWWWWWWWWWWWWWW..",
"..WWWWWWWWWWWWWWWWWWWWWWWWWWW..",
"..WWWWWWWWWWWWWWWWWWWWWWWWWWW..",
"..WWWWWWWWWWWWWWWWWWWWWWWWWWW..",
"...WWWWWWWWWWWWWWWWWWWWWWWWW...",
"...WWWWWWWWWWWWWWWWWWWWWWWWW...",
"....WWWWWWWWWWWWWWWWWWWWWWW....",
"....WWWWWWWWWWWWWWWWWWWWWWW....",
".....WWWWWWWWWWWWWWWWWWWWW.....",
"......WWWWWWWWWWWWWWWWWWW......",
".......WWWWWWWWWWWWWWWWW.......",
"........WWWWWWWWWWWWWWW........",
"..........WWWWWWWWWWW..........",
"............WWWWWWW............",
"...............................",
"..............................."
};

// XPM data for the 7x7 icon used for hexagonal CA
static const char* hex7x7[] = {
// width height ncolors chars_per_pixel
"7 7 2 1",
// colors
". c #000000",    // black will be transparent
"W c #FFFFFF",    // white
// pixels
".WW....",
"WWWWW..",
"WWWWWW.",
".WWWWW.",
".WWWWWW",
"..WWWWW",
"....WW."};

// XPM data for the 15x15 icon used for hexagonal CA
static const char* hex15x15[] = {
// width height ncolors chars_per_pixel
"15 15 2 1",
// colors
". c #000000",    // black will be transparent
"W c #FFFFFF",    // white
// pixels
"...WW..........",
"..WWWWW........",
".WWWWWWWW......",
"WWWWWWWWWWW....",
"WWWWWWWWWWWW...",
".WWWWWWWWWWW...",
".WWWWWWWWWWWW..",
"..WWWWWWWWWWW..",
"..WWWWWWWWWWWW.",
"...WWWWWWWWWWW.",
"...WWWWWWWWWWWW",
"....WWWWWWWWWWW",
"......WWWWWWWW.",
"........WWWWW..",
"..........WW..."};

// XPM data for 31x31 icon used for hexagonal CA
static const char* hex31x31[] = {
// width height ncolors chars_per_pixel
"31 31 2 1",
// colors
". c #000000",    // black will be transparent
"W c #FFFFFF",    // white
// pixels
".....WW........................",
"....WWWWW......................",
"...WWWWWWWW....................",
"..WWWWWWWWWWW..................",
".WWWWWWWWWWWWWW................",
"WWWWWWWWWWWWWWWWW..............",
"WWWWWWWWWWWWWWWWWWW............",
".WWWWWWWWWWWWWWWWWWWW..........",
".WWWWWWWWWWWWWWWWWWWWWW........",
"..WWWWWWWWWWWWWWWWWWWWW........",
"..WWWWWWWWWWWWWWWWWWWWWW.......",
"...WWWWWWWWWWWWWWWWWWWWW.......",
"...WWWWWWWWWWWWWWWWWWWWWW......",
"....WWWWWWWWWWWWWWWWWWWWW......",
"....WWWWWWWWWWWWWWWWWWWWWW.....",
".....WWWWWWWWWWWWWWWWWWWWW.....",
".....WWWWWWWWWWWWWWWWWWWWWW....",
"......WWWWWWWWWWWWWWWWWWWWW....",
"......WWWWWWWWWWWWWWWWWWWWWW...",
".......WWWWWWWWWWWWWWWWWWWWW...",
".......WWWWWWWWWWWWWWWWWWWWWW..",
"........WWWWWWWWWWWWWWWWWWWWW..",
"........WWWWWWWWWWWWWWWWWWWWWW.",
"..........WWWWWWWWWWWWWWWWWWWW.",
"............WWWWWWWWWWWWWWWWWWW",
"..............WWWWWWWWWWWWWWWWW",
"................WWWWWWWWWWWWWW.",
"..................WWWWWWWWWWW..",
"....................WWWWWWWW...",
"......................WWWWW....",
"........................WW....."
};

// XPM data for the 7x7 icon used for von Neumann CA
static const char* vn7x7[] = {
// width height ncolors chars_per_pixel
"7 7 2 1",
// colors
". c #000000",    // black will be transparent
"W c #FFFFFF",    // white
// pixels
"...W...",
"..WWW..",
".WWWWW.",
"WWWWWWW",
".WWWWW.",
"..WWW..",
"...W..."
};

// XPM data for the 15x15 icon used for von Neumann CA
static const char* vn15x15[] = {
// width height ncolors chars_per_pixel
"15 15 2 1",
// colors
". c #000000",    // black will be transparent
"W c #FFFFFF",    // white
// pixels
"...............",
".......W.......",
"......WWW......",
".....WWWWW.....",
"....WWWWWWW....",
"...WWWWWWWWW...",
"..WWWWWWWWWWW..",
".WWWWWWWWWWWWW.",
"..WWWWWWWWWWW..",
"...WWWWWWWWW...",
"....WWWWWWW....",
".....WWWWW.....",
"......WWW......",
".......W.......",
"..............."
};

// XPM data for 31x31 icon used for von Neumann CA
static const char* vn31x31[] = {
// width height ncolors chars_per_pixel
"31 31 2 1",
// colors
". c #000000",    // black will be transparent
"W c #FFFFFF",    // white
// pixels
"...............................",
"...............................",
"...............W...............",
"..............WWW..............",
".............WWWWW.............",
"............WWWWWWW............",
"...........WWWWWWWWW...........",
"..........WWWWWWWWWWW..........",
".........WWWWWWWWWWWWW.........",
"........WWWWWWWWWWWWWWW........",
".......WWWWWWWWWWWWWWWWW.......",
"......WWWWWWWWWWWWWWWWWWW......",
".....WWWWWWWWWWWWWWWWWWWWW.....",
"....WWWWWWWWWWWWWWWWWWWWWWW....",
"...WWWWWWWWWWWWWWWWWWWWWWWWW...",
"..WWWWWWWWWWWWWWWWWWWWWWWWWWW..",
"...WWWWWWWWWWWWWWWWWWWWWWWWW...",
"....WWWWWWWWWWWWWWWWWWWWWWW....",
".....WWWWWWWWWWWWWWWWWWWWW.....",
"......WWWWWWWWWWWWWWWWWWW......",
".......WWWWWWWWWWWWWWWWW.......",
"........WWWWWWWWWWWWWWW........",
".........WWWWWWWWWWWWW.........",
"..........WWWWWWWWWWW..........",
"...........WWWWWWWWW...........",
"............WWWWWWW............",
".............WWWWW.............",
"..............WWW..............",
"...............W...............",
"...............................",
"..............................."
};

// -----------------------------------------------------------------------------

static CGImageRef* CreateMonochromeBitmaps(const char** xpmdata, int maxstates)
{
    if (xpmdata == NULL) return NULL;
    
    int wd, ht, numcolors, charsperpixel;
    sscanf(xpmdata[0], "%d %d %d %d", &wd, &ht, &numcolors, &charsperpixel);

    // Note that all the default icons must be monochrome.
    // This is done because these icons are used for lots of different
    // rules with different numbers of states, and at rendering time
    // we want to replace the non-black color in each icon with the
    // cell's state color to avoid "color shock" when switching
    // between icon and non-icon view.
    if (numcolors != 2 || charsperpixel != 1) {
        Warning("Bug in CreateMonochromeBitmaps: numcolors is not 2");
        return NULL;
    };
    
    char whitech, blackch;
    for (int i = 0; i < numcolors; i++) {
        char ch;
        int rgb;
        sscanf(xpmdata[i+1], "%c c #%6x", &ch, &rgb);
        if (rgb == 0) {
            blackch = ch;
        } else {
            whitech = ch;
        }
    }
    
    // allocate and clear memory for all icon bitmaps in BGRA format
    // (using calloc means black pixels will be transparent)
    unsigned char* bgra = (unsigned char*) calloc(wd * ht * 4, 1);
    if (bgra == NULL) return NULL;
    int pos = 0;
    for (int i = 0; i < ht; i++) {
        const char* rowstring = xpmdata[i+1+numcolors];
        for (int j = 0; j < wd; j++) {
            if (rowstring[j] == whitech) {
                bgra[pos] = 255; pos++;
                bgra[pos] = 255; pos++;
                bgra[pos] = 255; pos++;
                bgra[pos] = 255; pos++;     // alpha
            } else {
                // pixel is black and alpha is 0
                pos += 4;
            }
        }
    }
    
    int numicons = ht / wd;
    if (numicons > 255) numicons = 255;     // play safe
    
    CGImageRef* iconptr = (CGImageRef*) malloc(256 * sizeof(CGImageRef));
    if (iconptr) {
        // only need to test < maxstates here, but play safe
        for (int i = 0; i < 256; i++) iconptr[i] = NULL;
        
        // convert each icon bitmap to a CGImage
        unsigned char* nexticon = bgra;
        CGColorSpaceRef colorspace = CGColorSpaceCreateDeviceRGB();
        for (int i = 0; i < numicons; i++) {
            CGContextRef context = CGBitmapContextCreate(nexticon, wd, wd, 8, wd * 4, colorspace,
                // following gives us the optimal BGRA format:
                kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);
            // add 1 to skip iconptr[0] (ie. dead state)
            iconptr[i+1] = CGBitmapContextCreateImage(context);
            CGContextRelease(context);
            nexticon += wd * wd * 4;
        }
        
        if (numicons < maxstates-1 && iconptr[numicons]) {
            // duplicate last icon
            nexticon -= wd * wd * 4;
            for (int i = numicons; i < maxstates-1; i++) {
                CGContextRef context = CGBitmapContextCreate(nexticon, wd, wd, 8, wd * 4, colorspace,
                    // following gives us the optimal BGRA format:
                    kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);
                iconptr[i+1] = CGBitmapContextCreateImage(context);
                CGContextRelease(context);
            }
        }
        CGColorSpaceRelease(colorspace);
    }
    
    if (bgra) free(bgra);
    return iconptr;
}

// -----------------------------------------------------------------------------

CGImageRef* ScaleIconBitmaps(CGImageRef* srcicons, int size)
{
    if (srcicons == NULL) return NULL;

    CGImageRef* iconptr = (CGImageRef*) malloc(256 * sizeof(CGImageRef));
    if (iconptr) {
        for (int i = 0; i < 256; i++) {
            if (srcicons[i] == NULL) {
                iconptr[i] = NULL;
            } else {
                CGImageRef srcimage = srcicons[i];
                size_t bytesPerRow = CGImageGetBitsPerPixel(srcimage) / CGImageGetBitsPerComponent(srcimage) * size;
                
                CGContextRef context = CGBitmapContextCreate(NULL, size, size,
                    CGImageGetBitsPerComponent(srcimage),
                    bytesPerRow,
                    CGImageGetColorSpace(srcimage),
                    CGImageGetBitmapInfo(srcimage));
                
                CGContextSetInterpolationQuality(context, kCGInterpolationHigh);
                CGContextDrawImage(context, CGRectMake(0, 0, size, size), srcimage);
                iconptr[i] = CGBitmapContextCreateImage(context);
                CGContextRelease(context);
            }
        }
    }
    return iconptr;
}

// -----------------------------------------------------------------------------

static void CreateDefaultIcons(AlgoData* ad)
{
    if (ad->defxpm7x7 || ad->defxpm15x15 || ad->defxpm31x31) {
        // create icons using given algo's default XPM data
        ad->icons7x7 = CreateMonochromeBitmaps(ad->defxpm7x7, ad->maxstates);
        ad->icons15x15 = CreateMonochromeBitmaps(ad->defxpm15x15, ad->maxstates);
        ad->icons31x31 = CreateMonochromeBitmaps(ad->defxpm31x31, ad->maxstates);
        
        // create scaled bitmaps if size(s) not supplied
        if (!ad->icons7x7) {
            if (ad->icons15x15)
                // scale down 15x15 bitmaps
                ad->icons7x7 = ScaleIconBitmaps(ad->icons15x15, 7);
            else
                // scale down 31x31 bitmaps
                ad->icons7x7 = ScaleIconBitmaps(ad->icons31x31, 7);
        }
        if (!ad->icons15x15) {
            if (ad->icons31x31)
                // scale down 31x31 bitmaps
                ad->icons15x15 = ScaleIconBitmaps(ad->icons31x31, 15);
            else
                // scale up 7x7 bitmaps
                ad->icons15x15 = ScaleIconBitmaps(ad->icons7x7, 15);
        }
        if (!ad->icons31x31) {
            if (ad->icons15x15)
                // scale up 15x15 bitmaps
                ad->icons31x31 = ScaleIconBitmaps(ad->icons15x15, 31);
            else
                // scale up 7x7 bitmaps
                ad->icons31x31 = ScaleIconBitmaps(ad->icons7x7, 31);
        }
    } else {
        // algo didn't supply any icons so use static XPM data defined above
        ad->icons7x7 = CreateMonochromeBitmaps(default7x7, ad->maxstates);
        ad->icons15x15 = CreateMonochromeBitmaps(default15x15, ad->maxstates);
        ad->icons31x31 = CreateMonochromeBitmaps(default31x31, ad->maxstates);
    }
}

// -----------------------------------------------------------------------------

AlgoData::AlgoData() {
    defbase = 0;
    icons7x7 = NULL;
    icons15x15 = NULL;
    icons31x31 = NULL;
}

// -----------------------------------------------------------------------------

AlgoData& AlgoData::tick() {
    AlgoData* r = new AlgoData();
    algoinfo[r->id] = r;
    return *r;
}

// -----------------------------------------------------------------------------

void InitAlgorithms()
{
    // qlife must be 1st and hlife must be 2nd
    qlifealgo::doInitializeAlgoInfo(AlgoData::tick());
    hlifealgo::doInitializeAlgoInfo(AlgoData::tick());
    
    // nicer if the rest are in alphabetical order
    generationsalgo::doInitializeAlgoInfo(AlgoData::tick());
    jvnalgo::doInitializeAlgoInfo(AlgoData::tick());
    ruleloaderalgo::doInitializeAlgoInfo(AlgoData::tick());
    
    // init algoinfo array
    for (int i = 0; i < NumAlgos(); i++) {
        AlgoData* ad = algoinfo[i];
        if (ad->algoName == 0 || ad->creator == 0)
            Fatal("Algorithm did not set name and/or creator");
        
        // does algo use hashing?
        ad->canhash = ad->defbase == 8;    // safer method needed???
         
        // set status bar background by cycling thru a few pale colors
        switch (i % 9) {
            case 0: SetColor(ad->statusrgb, 255, 255, 206); break;  // pale yellow
            case 1: SetColor(ad->statusrgb, 226, 250, 248); break;  // pale blue
            case 2: SetColor(ad->statusrgb, 255, 233, 233); break;  // pale pink
            case 3: SetColor(ad->statusrgb, 225, 255, 225); break;  // pale green
            case 4: SetColor(ad->statusrgb, 243, 225, 255); break;  // pale purple
            case 5: SetColor(ad->statusrgb, 255, 220, 180); break;  // pale orange
            case 6: SetColor(ad->statusrgb, 200, 255, 255); break;  // pale aqua
            case 7: SetColor(ad->statusrgb, 200, 200, 200); break;  // pale gray
            case 8: SetColor(ad->statusrgb, 255, 255, 255); break;  // white
        }
        
        // initialize default color scheme
        if (ad->defr[0] == ad->defr[1] &&
            ad->defg[0] == ad->defg[1] &&
            ad->defb[0] == ad->defb[1]) {
            // colors are nonsensical, probably unset, so use above defaults
            unsigned char* rgbptr = default_colors;
            for (int c = 0; c < ad->maxstates; c++) {
                ad->defr[c] = *rgbptr++;
                ad->defg[c] = *rgbptr++;
                ad->defb[c] = *rgbptr++;
            }
        }
        ad->gradient = ad->defgradient;
        SetColor(ad->fromrgb, ad->defr1, ad->defg1, ad->defb1);
        SetColor(ad->torgb, ad->defr2, ad->defg2, ad->defb2);
        for (int c = 0; c < ad->maxstates; c++) {
            ad->algor[c] = ad->defr[c];
            ad->algog[c] = ad->defg[c];
            ad->algob[c] = ad->defb[c];
        }
        
        CreateDefaultIcons(ad);
    }
    
    hexicons7x7 = CreateMonochromeBitmaps(hex7x7,256);
    hexicons15x15 = CreateMonochromeBitmaps(hex15x15,256);
    hexicons31x31 = CreateMonochromeBitmaps(hex31x31,256);
     
    vnicons7x7 = CreateMonochromeBitmaps(vn7x7,256);
    vnicons15x15 = CreateMonochromeBitmaps(vn15x15,256);
    vnicons31x31 = CreateMonochromeBitmaps(vn31x31,256);
}

// -----------------------------------------------------------------------------

lifealgo* CreateNewUniverse(algo_type algotype, bool allowcheck)
{
    lifealgo* newalgo = algoinfo[algotype]->creator();
    
    if (newalgo == NULL) Fatal("Failed to create new universe!");
    
    if (algoinfo[algotype]->canhash) {
        newalgo->setMaxMemory(maxhashmem);
    }
    // non-hashing algos (QuickLife) use their default memory setting
    
    if (allowcheck) newalgo->setpoll(Poller());
    
    return newalgo;
}

// -----------------------------------------------------------------------------

const char* GetAlgoName(algo_type algotype)
{
    return algoinfo[algotype]->algoName;
}

// -----------------------------------------------------------------------------

int NumAlgos()
{
    return staticAlgoInfo::getNumAlgos();
}

// -----------------------------------------------------------------------------

static bool MultiColorImage(CGImageRef image)
{
    // return true if given image contains more than 2 different colors
    int wd = CGImageGetWidth(image);
    int ht = CGImageGetHeight(image);
    int bytesPerPixel = 4;
    int bytesPerRow = bytesPerPixel * wd;
    int bitsPerComponent = 8;

    // allocate memory to store image's RGBA bitmap data
    unsigned char* pxldata = (unsigned char*) calloc(wd * ht * 4, 1);
    if (pxldata == NULL) return false;

    CGColorSpaceRef colorspace = CGColorSpaceCreateDeviceRGB();
    CGContextRef ctx = CGBitmapContextCreate(pxldata, wd, ht,
        bitsPerComponent, bytesPerRow, colorspace,
        kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);
    CGContextDrawImage(ctx, CGRectMake(0, 0, wd, ht), image);
    CGContextRelease(ctx);
    CGColorSpaceRelease(colorspace);

    // pxldata now contains the image bitmap in RGBA pixel format
    int color1 = -1;
    int color2 = -1;
    int byte = 0;
    for (int i = 0; i < wd*ht; i++) {
        int color = (pxldata[byte] << 16) + (pxldata[byte+1] << 8) + pxldata[byte+2];
        if (color == color1 || color == color2) {
            // continue
        } else {
            // 1st time we've seen this color
            if (color1 == -1) {
                color1 = color;
            } else if (color2 == -1) {
                color2 = color;
            } else {
                // this is the 3rd different color
                free(pxldata);
                return true;
            }
        }
        byte += 4;
    }

    free(pxldata);
    return false;
}

// -----------------------------------------------------------------------------

bool LoadIconFile(const std::string& path, int maxstate,
                  CGImageRef** out7x7, CGImageRef** out15x15, CGImageRef** out31x31)
{
    CGImageRef allicons = [UIImage imageWithContentsOfFile:
        [NSString stringWithCString:path.c_str() encoding:NSUTF8StringEncoding]].CGImage;
    if (allicons == NULL) {
        std::string msg = "Could not load icon bitmaps from file:\n";
        msg += path;
        NSLog(@"%s", msg.c_str());
        Warning(msg.c_str());
        return false;
    }
    
    // check dimensions of .icons format
    int wd = CGImageGetWidth(allicons);
    int ht = CGImageGetHeight(allicons);
    if (ht != 15 && ht != 22) {
        Warning("Wrong bitmap height in .icons file (must be 15 or 22).");
        return false;
    }
    if (wd % 15 != 0) {
        Warning("Wrong bitmap width in .icons file (must be multiple of 15).");
        return false;
    }
    
    currlayer->multicoloricons = MultiColorImage(allicons);
    
    // first extract 15x15 icons
    int numicons = wd / 15;
    if (numicons > 255) numicons = 255;     // play safe
    
    CGImageRef* iconptr = (CGImageRef*) malloc(256 * sizeof(CGImageRef));
    if (iconptr) {
        for (int i = 0; i < 256; i++) iconptr[i] = NULL;
        for (int i = 0; i < numicons; i++) {
            // add 1 to skip iconptr[0] (ie. dead state)
            iconptr[i+1] = CGImageCreateWithImageInRect(allicons, CGRectMake(i*15, 0, 15, 15));
        }
        if (numicons < maxstate && iconptr[numicons]) {
            // duplicate last icon
            for (int i = numicons; i < maxstate; i++) {
                iconptr[i+1] = CGImageCreateWithImageInRect(allicons, CGRectMake((numicons-1)*15, 0, 15, 15));
            }
        }
        
        // if there is an extra icon at the right end of the multi-color icons then
        // store it in iconptr[0] -- it will be used later in UpdateCurrentColors()
        // to set the color of state 0
        if (currlayer->multicoloricons && (wd / 15) > maxstate) {
            iconptr[0] = CGImageCreateWithImageInRect(allicons, CGRectMake(maxstate*15, 0, 15, 15));
        }
    }
    *out15x15 = iconptr;
    
    if (ht == 22) {
        // extract 7x7 icons (at bottom left corner of each 15x15 icon)
        iconptr = (CGImageRef*) malloc(256 * sizeof(CGImageRef));
        if (iconptr) {
            for (int i = 0; i < 256; i++) iconptr[i] = NULL;
            for (int i = 0; i < numicons; i++) {
                // add 1 to skip iconptr[0] (ie. dead state)
                iconptr[i+1] = CGImageCreateWithImageInRect(allicons, CGRectMake(i*15, 15, 7, 7));
            }
            if (numicons < maxstate && iconptr[numicons]) {
                // duplicate last icon
                for (int i = numicons; i < maxstate; i++) {
                    iconptr[i+1] = CGImageCreateWithImageInRect(allicons, CGRectMake((numicons-1)*15, 15, 7, 7));
                }
            }
        }
        *out7x7 = iconptr;
    } else {
        // create 7x7 icons by scaling down 15x15 icons
        *out7x7 = ScaleIconBitmaps(*out15x15, 7);
    }

    // create 31x31 icons by scaling up 15x15 icons
    *out31x31 = ScaleIconBitmaps(*out15x15, 31);
    
    return true;
}
